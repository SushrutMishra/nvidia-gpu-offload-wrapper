#!/usr/bin/env bash
#
# wrap-nvidia-complete.sh
#
# Wrap GUI apps to run on NVIDIA GPU via DRI_PRIME=1 and VK_ICD_FILENAMES
# Spec-compliant, production-ready wrapper with XDG support, auditing modes,
# and safety/hardening improvements (locking, atomic writes, validation).
#
# Limitations:
# - Wayland-native apps may not benefit from DRI_PRIME
# - Exec entries using "sh -c" or containing quoted arguments are skipped
# - Desktop launchers may cache entries; restart launcher or session if needed
#
set -euo pipefail

# -------------------- locking to avoid concurrent runs -------------------------
LOCKFILE="/tmp/$(basename "$0").lock"
exec 9>"$LOCKFILE"
if ! flock -n 9; then
  echo "Another instance of $(basename "$0") is running (lock: $LOCKFILE). Exiting."
  exit 2
fi
# (fd 9 will be closed automatically on exit, releasing the lock)
# ------------------------------------------------------------------------------

# -------------------- XDG-aware source directories ----------------------------
SRC_DIRS=()
: "${XDG_DATA_DIRS:=/usr/local/share:/usr/share}"
SRC_DIRS+=("$HOME/.local/share/applications")
IFS=':' read -ra _xdg <<< "$XDG_DATA_DIRS"
for d in "${_xdg[@]}"; do
  SRC_DIRS+=("$d/applications")
done
# ------------------------------------------------------------------------------

# -------------------- defaults and configurable vars --------------------------
DEST_DIR="$HOME/.local/share/applications-nvidia"
WRAPPER_SCRIPT="$HOME/.local/bin/nvidia-offload"
BACKUP_DIR_DEFAULT="$DEST_DIR/.backup-$(date +%Y%m%d-%H%M%S)"
BACKUP_DIR=""
DRY_RUN=0
ASSUME_YES=0
USE_WRAPPER=1
AGGRESSIVE=0
UNINSTALL=0
WRAPPER_LOGGING=0
RESTORE=0
LIST_MODE=0
LIST_JSON=0
EXPLAIN_FILE=""
VERIFY_MODE=0
# ------------------------------------------------------------------------------

# -------------------- policy lists (tweak these as you like) ------------------
ALWAYS_CPU_APPS=( "htop" "btop" "nvtop" "top" "gedit" "kate" "nano" "vim" "emacs" "pluma" "gnome-terminal" "konsole" "xterm" "alacritty" "kitty" "tilix" "thunar" "nautilus" "dolphin" "nemo" "pcmanfm" )
OPTIONAL_GPU_APPS=( "code" "codium" "atom" "sublime" "libreoffice" "writer" "calc" "impress" "draw" "evince" "okular" "atril" "firefox" "chromium" )
SKIP_PATTERNS=( "x-gnome" "kwin" "plasma" "display" "settings" "system" "desktop" "notification" "panel" "shell" "session" "screensaver" "polkit" )
# ------------------------------------------------------------------------------

# -------------------- colors & logging helpers --------------------------------
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; NC='\033[0m'
log_info()  { echo -e "${GREEN}[INFO]${NC}  $*"; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC}  $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }
log_debug() { [ "${DEBUG:-0}" -eq 1 ] && echo -e "${BLUE}[DEBUG]${NC} $*"; }
# ------------------------------------------------------------------------------

# -------------------- CLI usage ------------------------------------------------
usage() {
  cat <<EOF
Usage: $(basename "$0") [options]

Options:
  --dest DIR           Destination dir for wrapped .desktop files (default: $DEST_DIR)
  --backup-dir DIR     Backup folder for previous wrapped files (default: autogenerated)
  --wrapper-script DIR Path to wrapper script (default: $WRAPPER_SCRIPT)
  --no-wrapper         Inline env vars into Exec instead of calling wrapper
  --aggressive         Also wrap apps in OPTIONAL_GPU_APPS
  --wrapper-logging    Enable debug logging in wrapper script
  --dry-run            Show what would be done (no writes)
  --yes                Non-interactive (assume yes prompts)
  --verify             Create & run verification helper after wrapping
  --uninstall          Remove DEST_DIR and wrapper
  --restore            Restore .desktop files from BACKUP_DIR to DEST_DIR
  --list               List candidates and reasons
  --json               Output --list results as JSON (use with --list)
  --explain FILE       Explain decision for one .desktop file
  -h, --help           Show this help
EOF
}
# ------------------------------------------------------------------------------

# -------------------- parse args ----------------------------------------------
while [ $# -gt 0 ]; do
  case "$1" in
    --dest) DEST_DIR="$2"; shift 2;;
    --backup-dir) BACKUP_DIR="$2"; shift 2;;
    --wrapper-script) WRAPPER_SCRIPT="$2"; shift 2;;
    --no-wrapper) USE_WRAPPER=0; shift;;
    --aggressive) AGGRESSIVE=1; shift;;
    --wrapper-logging) WRAPPER_LOGGING=1; shift;;
    --dry-run) DRY_RUN=1; shift;;
    --yes) ASSUME_YES=1; shift;;
    --verify) VERIFY_MODE=1; shift;;
    --uninstall) UNINSTALL=1; shift;;
    --restore) RESTORE=1; shift;;
    --list) LIST_MODE=1; shift;;
    --json) LIST_JSON=1; shift;;
    --explain) EXPLAIN_FILE="$2"; shift 2;;
    -h|--help) usage; exit 0;;
    *) log_error "Unknown arg: $1"; usage; exit 2;;
  esac
done
BACKUP_DIR="${BACKUP_DIR:-$BACKUP_DIR_DEFAULT}"
# ------------------------------------------------------------------------------

# -------------------- small helpers -------------------------------------------
trim() { local s="$1"; s="${s%%#*}"; s="${s#"${s%%[![:space:]]*}"}"; s="${s%"${s##*[![:space:]]}"}"; printf '%s' "$s"; }
# ------------------------------------------------------------------------------

# -------------------- load user opt-outs -------------------------------------
USER_SKIP_LIST=()
USER_SKIP_CONF="$HOME/.config/nvidia-wrapper-skip.conf"
if [ -f "$USER_SKIP_CONF" ]; then
  while IFS= read -r line; do
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$line" ]] && continue
    line="$(trim "$line")"
    [ -n "$line" ] && USER_SKIP_LIST+=("$line")
  done < "$USER_SKIP_CONF"
  [ ${#USER_SKIP_LIST[@]} -gt 0 ] && log_info "Loaded ${#USER_SKIP_LIST[@]} user opt-outs from $USER_SKIP_CONF"
fi
# ------------------------------------------------------------------------------

# -------------------- uninstall / restore -------------------------------------
do_uninstall() {
  log_info "Uninstalling..."
  if [ "$DRY_RUN" -eq 1 ]; then
    log_info "[dry-run] Would remove: $DEST_DIR"
    [ -f "$WRAPPER_SCRIPT" ] && log_info "[dry-run] Would remove: $WRAPPER_SCRIPT"
    return
  fi
  [ -d "$DEST_DIR" ] && rm -rf "$DEST_DIR" && log_info "Removed: $DEST_DIR"
  [ -f "$WRAPPER_SCRIPT" ] && rm -f "$WRAPPER_SCRIPT" && log_info "Removed: $WRAPPER_SCRIPT"
  [ -f "$HOME/.local/bin/nvidia-offload-verify" ] && rm -f "$HOME/.local/bin/nvidia-offload-verify" && log_info "Removed verify helper"
  if [ -d "$BACKUP_DIR" ]; then log_info "Backups left in: $BACKUP_DIR (not removed)"; fi
  log_info "Uninstall complete. Restart your app launcher to clear cache."
  exit 0
}

# Restore: move *.desktop from backup -> dest and remove backup metadata if empty
do_restore() {
  log_info "Restoring backup from $BACKUP_DIR..."
  if [ "$DRY_RUN" -eq 1 ]; then
    log_info "[dry-run] Would restore files from: $BACKUP_DIR"
    return
  fi
  if [ -z "${BACKUP_DIR:-}" ] || [ ! -d "$BACKUP_DIR" ]; then
    log_error "Backup directory not found or not set: ${BACKUP_DIR:-<unset>}"
    exit 1
  fi
  mkdir -p "$DEST_DIR"
  local moved=0
  while IFS= read -r -d '' f; do
    dest="$DEST_DIR/$(basename "$f")"
    mv -f "$f" "$dest" && moved=$((moved+1)) || log_warn "Failed to move $f -> $dest"
  done < <(find "$BACKUP_DIR" -maxdepth 1 -type f -name '*.desktop' -print0)
  log_info "Restored $moved files to $DEST_DIR"
  if [ -d "$BACKUP_DIR" ] && [ -z "$(ls -A "$BACKUP_DIR" 2>/dev/null)" ]; then
    rmdir "$BACKUP_DIR" 2>/dev/null || true
  fi
  log_info "Restore complete. Restart your app launcher if needed."
  exit 0
}

[ "$UNINSTALL" -eq 1 ] && do_uninstall
[ "$RESTORE" -eq 1 ] && do_restore
# ------------------------------------------------------------------------------

# -------------------- validation & environment helpers -------------------------
validate_wrapper_path() {
  [ "$USE_WRAPPER" -eq 1 ] || return 0
  case "$WRAPPER_SCRIPT" in /*) ;; *) log_error "Wrapper script path must be absolute: $WRAPPER_SCRIPT"; exit 2;; esac
  [[ "$WRAPPER_SCRIPT" =~ [[:space:]] ]] && { log_error "Wrapper path must not contain spaces"; exit 2; }
}

detect_driver() {
  if lspci -k 2>/dev/null | grep -A 3 "VGA\|3D" | grep -qi "nouveau"; then
    echo "nouveau"
  elif lspci -k 2>/dev/null | grep -A 3 "VGA\|3D" | grep -qi "nvidia"; then
    echo "nvidia"
  elif [ -f /proc/driver/nvidia/version ]; then
    echo "nvidia"
  else
    echo "unknown"
  fi
}
# ------------------------------------------------------------------------------

# -------------------- wrapper creation ----------------------------------------
create_wrapper_script() {
  [ "$USE_WRAPPER" -ne 1 ] && { log_info "Wrapper disabled -- using inline env"; return 0; }
  [ "$DRY_RUN" -eq 1 ] && { log_info "[dry-run] Would create wrapper script at $WRAPPER_SCRIPT"; return 0; }

  mkdir -p "$(dirname "$WRAPPER_SCRIPT")"
  local driver; driver="$(detect_driver)"; log_info "Detected driver: $driver"

  # Collect relevant Vulkan ICD json files (multi-arch/multi-gpu)
  local vulkan_icds=()
  for icd in /usr/share/vulkan/icd.d/*.json /etc/vulkan/icd.d/*.json; do
    [ -f "$icd" ] || continue
    if grep -qiE 'nvidia|nouveau' "$icd" 2>/dev/null; then
      vulkan_icds+=("$icd")
    fi
  done

  local vulkan_icd=""
  if [ ${#vulkan_icds[@]} -gt 0 ]; then
    for icd in "${vulkan_icds[@]}"; do [[ "$icd" == *nvidia* ]] && { vulkan_icd="$icd"; break; } ; done
    [ -z "$vulkan_icd" ] && vulkan_icd="${vulkan_icds[0]}"
    if [ ${#vulkan_icds[@]} -gt 1 ]; then vulkan_icd="$(IFS=:; echo "${vulkan_icds[*]}")"; log_info "Multiple Vulkan ICDs detected"; else log_info "Vulkan ICD: $vulkan_icd"; fi
  else
    log_warn "No Vulkan ICD found"
  fi

  cat > "$WRAPPER_SCRIPT" <<'WRAPPER_EOF'
#!/usr/bin/env bash
# NVIDIA GPU Offload Wrapper (auto-generated)
trap 'kill -TERM "$child" 2>/dev/null' TERM INT
export DRI_PRIME=1
WRAPPER_EOF

  if [ "$driver" = "nvidia" ]; then
    echo 'export __GLX_VENDOR_LIBRARY_NAME=nvidia' >> "$WRAPPER_SCRIPT"
    echo 'export __NV_PRIME_RENDER_OFFLOAD=1' >> "$WRAPPER_SCRIPT"
  else
    echo '# Using nouveau/mesa (GLX vendor not overridden)' >> "$WRAPPER_SCRIPT"
  fi

  if [ -n "$vulkan_icd" ]; then
    cat >> "$WRAPPER_SCRIPT" <<VKEOF
# Vulkan ICD - append to existing if set (safe for Steam/DXVK)
if [ -n "\$VK_ICD_FILENAMES" ]; then
  export VK_ICD_FILENAMES="\$VK_ICD_FILENAMES:$vulkan_icd"
else
  export VK_ICD_FILENAMES="$vulkan_icd"
fi
VKEOF
  else
    echo "# VK_ICD_FILENAMES not set (no ICD found)" >> "$WRAPPER_SCRIPT"
  fi

  cat >> "$WRAPPER_SCRIPT" <<'WRAPPER_EOF'

# Wayland compatibility
if [ -n "$WAYLAND_DISPLAY" ]; then
  export GDK_BACKEND=wayland,x11
fi

# Execute requested command (preserves field codes and args)
exec "$@"
WRAPPER_EOF

  chmod 0755 "$WRAPPER_SCRIPT"
  chown "$(id -u):$(id -g)" "$WRAPPER_SCRIPT" 2>/dev/null || true
  log_info "Created wrapper script: $WRAPPER_SCRIPT"
}
# ------------------------------------------------------------------------------

# -------------------- sanity check for offload capability ----------------------
check_nvidia() {
  if ! command -v glxinfo &>/dev/null; then
    log_warn "glxinfo not found; install mesa-utils to verify GPU setup"
    return 0
  fi

  if DRI_PRIME=1 glxinfo 2>/dev/null | grep -qiE "nvidia|nouveau"; then
    local renderer
    renderer="$(DRI_PRIME=1 glxinfo 2>/dev/null | grep "OpenGL renderer" | cut -d: -f2 | xargs)"
    log_info "Discrete GPU detected via PRIME: $renderer"

    if command -v vulkaninfo &>/dev/null; then
      if DRI_PRIME=1 vulkaninfo --summary 2>/dev/null | grep -qiE "nvidia|nouveau"; then
        log_info "Vulkan support: OK"
      else
        log_warn "Vulkan may not be configured for offload"
      fi
    fi
    return 0
  else
    log_warn "No NVIDIA GPU detected with DRI_PRIME=1"
    [ "$ASSUME_YES" -eq 1 ] && { log_info "--yes provided; continuing"; return 0; }
    read -r -p "Continue anyway? (y/N): " REPLY
    case "$REPLY" in
      [Yy]*) return 0 ;;
      *) exit 1 ;;
    esac
  fi
}
# ------------------------------------------------------------------------------

# -------------------- OnlyShowIn (spec-compliant) --------------------------------
check_onlyshowin() {
  local only_show="$1"
  local current="${XDG_CURRENT_DESKTOP:-}"
  [ -z "$only_show" ] && return 0
  [ -z "$current" ] && return 0

  IFS=':;' read -ra current_parts <<< "$current"
  IFS=';'   read -ra only_parts    <<< "$only_show"

  for only in "${only_parts[@]}"; do
    [ -z "$only" ] && continue
    for curr in "${current_parts[@]}"; do
      [ -z "$curr" ] && continue
      if [ "$only" = "$curr" ]; then
        return 0
      fi
    done
  done
  return 1
}
# ------------------------------------------------------------------------------

# -------------------- desktop entry helpers ------------------------------------
get_field() { awk -F= -v k="$2" 'tolower($1)==tolower(k){sub($1 FS,""); print; exit}' "$1" 2>/dev/null || true; }

should_skip() {
  local file="$1"
  local __reason_var="${2:-}"
  local content; content="$(tr '[:upper:]' '[:lower:]' < "$file" 2>/dev/null || true)"
  local basename_lower; basename_lower="$(basename "$file" .desktop | tr '[:upper:]' '[:lower:]')"

  # User opt-out
  for skip_app in "${USER_SKIP_LIST[@]}"; do
    if [[ "$basename_lower" == *"$skip_app"* ]]; then
      [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "User opt-out"
      return 0
    fi
  done

  # Steam detection: skip wrapping Steam itself (it manages per-game GPU settings)
  if [[ "$basename_lower" == steam* ]]; then
    [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "Steam (managed per-game)"
    return 0
  fi

  # NoDisplay / Hidden
  if grep -qiE '^(no)?display=true' "$file" 2>/dev/null || grep -qiE '^hidden=true' "$file" 2>/dev/null; then
    [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "NoDisplay/Hidden"
    return 0
  fi

  # DBus-activated
  if grep -qiE '^DBusActivatable=true' "$file" 2>/dev/null; then
    [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "DBusActivatable"
    return 0
  fi

  # Flatpak / AppImage heuristics (often sandboxed/self-contained)
  if grep -qiE '^Exec=.*flatpak run' "$file" 2>/dev/null; then
    [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "Flatpak sandboxed"
    return 0
  fi
  if grep -qiE '^Exec=.*\.AppImage' "$file" 2>/dev/null; then
    [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "AppImage self-contained"
    return 0
  fi

  # Wayland-only (strict)
  if grep -qiE '^exec=.*--ozone-platform=wayland([[:space:]]|$)' "$file" 2>/dev/null; then
    [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "Wayland-only"
    return 0
  fi

  # Always-CPU apps
  for cpu_app in "${ALWAYS_CPU_APPS[@]}"; do
    if [[ "$basename_lower" == *"$cpu_app"* ]]; then
      [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "Always-CPU"
      return 0
    fi
  done

  # Optional apps (skip unless aggressive)
  if [ "$AGGRESSIVE" -eq 0 ]; then
    for opt_app in "${OPTIONAL_GPU_APPS[@]}"; do
      if [[ "$basename_lower" == *"$opt_app"* ]]; then
        [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "Optional (use --aggressive)"
        return 0
      fi
    done
  fi

  # System patterns
  for pattern in "${SKIP_PATTERNS[@]}"; do
    if echo "$content" | grep -qE "(name=.*${pattern}|exec=.*${pattern}|categories=.*${pattern})"; then
      [ -n "$__reason_var" ] && printf -v "$__reason_var" '%s' "System pattern"
      return 0
    fi
  done

  return 1
}
# ------------------------------------------------------------------------------

# -------------------- extract_target_bin (fixed) --------------------------------
extract_target_bin() {
  local tryexec="$1"
  local exec_line="$2"
  local target_bin=""
  local rest token

  if [ -n "$tryexec" ]; then
    target_bin="${tryexec%% *}"
  else
    # take first token (may be env VAR=val or 'env')
    token="${exec_line%% *}"
    rest="${exec_line#* }"

    # If the first token is "env", skip it and parse remainder
    if [ "$token" = "env" ]; then
      # rest now starts after "env "
      token="${rest%% *}"
      rest="${rest#* }"
    fi

    target_bin="$token"

    # If token looks like VAR=val, skip leading env assignments
    while [[ "$target_bin" == *=* ]]; do
      # if no rest, break
      if [ -z "${rest:-}" ] || [ "$rest" = "$exec_line" ]; then
        break
      fi
      target_bin="${rest%% *}"
      rest="${rest#* }"
    done
  fi

  # Resolve to absolute path for better deduplication if available
  if [ -n "$target_bin" ] && command -v "$target_bin" &>/dev/null; then
    command -v "$target_bin" 2>/dev/null || printf '%s' "$target_bin"
  else
    printf '%s' "$target_bin"
  fi
}
# ------------------------------------------------------------------------------

# -------------------- explain mode ------------------------------------------------
do_explain() {
  local file="$EXPLAIN_FILE"
  if [ ! -f "$file" ]; then
    log_error "File not found: $file"
    exit 1
  fi

  echo "=== Analysis of $(basename "$file") ==="
  echo "Location: $file"
  echo "Name: $(get_field "$file" "Name")"
  echo "Exec: $(get_field "$file" "Exec")"
  echo "TryExec: $(get_field "$file" "TryExec")"
  echo "OnlyShowIn: $(get_field "$file" "OnlyShowIn")"
  echo "NotShowIn: $(get_field "$file" "NotShowIn")"
  echo "DBusActivatable: $(get_field "$file" "DBusActivatable")"
  echo "NoDisplay: $(get_field "$file" "NoDisplay")"
  echo "Hidden: $(get_field "$file" "Hidden")"
  echo "Current DE: ${XDG_CURRENT_DESKTOP:-<not set>}"
  echo

  local skip_reason=""
  if should_skip "$file" skip_reason; then
    echo "Decision: SKIP"
    echo "Reason: $skip_reason"
  else
    echo "Decision: WOULD WRAP"
    echo "Reason: Matches wrapping criteria"
    local tryexec exec_line target_bin
    tryexec="$(get_field "$file" "TryExec")"
    exec_line="$(get_field "$file" "Exec")"
    target_bin="$(extract_target_bin "$tryexec" "$exec_line")"
    echo "Target binary: $target_bin"
  fi

  exit 0
}
[ -n "$EXPLAIN_FILE" ] && do_explain
# ------------------------------------------------------------------------------

# -------------------- backup existing wrapped apps -----------------------------
backup_existing() {
  if [ -d "$DEST_DIR" ] && find "$DEST_DIR" -maxdepth 1 -type f -name '*.desktop' -print -quit | grep -q .; then
    if [ "$DRY_RUN" -eq 1 ]; then
      log_info "[dry-run] Would back up existing apps to $BACKUP_DIR"
      return
    fi
    log_info "Backing up existing apps to $BACKUP_DIR"
    mkdir -p "$BACKUP_DIR"
    # Create a small metadata file so restore knows version
    cat > "$BACKUP_DIR/.nvidia-backup-meta" <<META
X-NVIDIA-Backup-Version=1.0
Origin-DEST-DIR=${DEST_DIR}
Timestamp=$(date -Iseconds)
META

    while IFS= read -r -d '' f; do
      mv -- "$f" "$BACKUP_DIR/"
    done < <(find "$DEST_DIR" -maxdepth 1 -type f -name '*.desktop' -print0)
  fi
}
# ------------------------------------------------------------------------------

# -------------------- list (--list / --json) -----------------------------------
do_list() {
  if [ "$LIST_JSON" -eq 1 ]; then
    echo "["
    local json_count=0
  else
    echo "=== Desktop Application Wrap Analysis ==="
    printf "%-10s %-40s %s\n" "STATUS" "FILE" "REASON"
    printf "%-10s %-40s %s\n" "----------" "----------------------------------------" "------------------------------"
  fi

  for SRC in "${SRC_DIRS[@]}"; do
    [ -d "$SRC" ] || continue
    while IFS= read -r -d '' FILE; do
      [ -f "$FILE" ] || continue
      local basename name status reason
      basename="$(basename "$FILE")"
      name="$(get_field "$FILE" "Name")"
      status="WRAP"
      reason="Would wrap"

      if grep -q '^X-NVIDIA-Wrapped=true' "$FILE" 2>/dev/null; then
        status="WRAPPED"; reason="Already wrapped"
      elif should_skip "$FILE" reason; then
        status="SKIP"
      else
        local tryexec exec_line
        tryexec="$(get_field "$FILE" "TryExec")"
        exec_line="$(get_field "$FILE" "Exec")"
        if [ -n "$tryexec" ] && ! command -v "${tryexec%% *}" &>/dev/null; then
          status="SKIP"; reason="TryExec missing"
        elif echo "$exec_line" | grep -qE '^(sh|bash|/bin/sh|/bin/bash)[[:space:]]+-c' || echo "$exec_line" | grep -q '"'; then
          status="SKIP"; reason="Shell-wrapped or quoted Exec"
        elif echo "$exec_line" | grep -qE 'DRI_PRIME|VK_ICD_FILENAMES|__GLX_VENDOR_LIBRARY_NAME|__NV_PRIME_RENDER_OFFLOAD'; then
          status="SKIP"; reason="Already has GPU env vars"
        fi
      fi

      if [ "$LIST_JSON" -eq 1 ]; then
        [ "$json_count" -gt 0 ] && echo ","
        json_count=$((json_count+1))
        # Escape simple JSON characters in strings
        esc() { printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\t/\\t/g' -e 's/\r/\\r/g' -e 's/\n/\\n/g'; }
        cat <<JSON
  {
    "file": "$(esc "$basename")",
    "path": "$(esc "$FILE")",
    "name": "$(esc "$name")",
    "status": "$(esc "$status")",
    "reason": "$(esc "$reason")"
  }
JSON
      else
        printf "%-10s %-40s %s\n" "$status" "$basename" "$reason"
      fi
    done < <(find "$SRC" -maxdepth 1 -type f -name '*.desktop' -print0 2>/dev/null)
  done

  if [ "$LIST_JSON" -eq 1 ]; then
    echo
    echo "]"
  fi
  exit 0
}

[ "$LIST_MODE" -eq 1 ] && do_list
# ------------------------------------------------------------------------------

# -------------------- main wrapping logic -------------------------------------
wrap_applications() {
  local count=0
  local skipped=0
  local tmpf=""

  trap 'rm -f "${tmpf:-}" 2>/dev/null || true' ERR

  mkdir -p "$DEST_DIR"
  log_info "Scanning desktop applications..."
  [ "$AGGRESSIVE" -eq 1 ] && log_info "Aggressive mode: wrapping optional GPU apps"

  declare -A seen_bins=()

  for SRC in "${SRC_DIRS[@]}"; do
    [ -d "$SRC" ] || continue
    while IFS= read -r -d '' FILE; do
      [ -f "$FILE" ] || continue
      APP_NAME="$(basename "$FILE" .desktop)"

      # Skip already wrapped
      if grep -q '^X-NVIDIA-Wrapped=true' "$FILE" 2>/dev/null; then
        continue
      fi

      # Policy skip
      if should_skip "$FILE"; then
        skipped=$((skipped+1))
        continue
      fi

      # Respect TryExec
      local tryexec
      tryexec="$(get_field "$FILE" "TryExec")"
      if [ -n "$tryexec" ] && ! command -v "${tryexec%% *}" &>/dev/null; then
        log_debug "Skipping $(basename "$FILE"): TryExec not found ($tryexec)"
        skipped=$((skipped+1))
        continue
      fi

      # OnlyShowIn / NotShowIn handling (NotShowIn: compare components per spec)
      local only_show not_show current_de
      only_show="$(get_field "$FILE" "OnlyShowIn")"
      not_show="$(get_field "$FILE" "NotShowIn")"
      current_de="${XDG_CURRENT_DESKTOP:-}"

      if [ -n "$only_show" ] && [ -n "$current_de" ] && ! check_onlyshowin "$only_show"; then
        log_debug "Skipping $(basename "$FILE"): OnlyShowIn=$only_show (current: $current_de)"
        skipped=$((skipped+1))
        continue
      fi

      if [ -n "$not_show" ] && [ -n "$current_de" ]; then
        IFS=':;' read -ra current_parts <<< "$current_de"
        IFS=':;' read -ra nf <<< "$not_show"
        skip_nf=0
        for p in "${nf[@]}"; do
          [ -z "$p" ] && continue
          for curr in "${current_parts[@]}"; do
            [ -z "$curr" ] && continue
            if [ "$p" = "$curr" ]; then
              skip_nf=1
              break 2
            fi
          done
        done
        if [ "$skip_nf" -eq 1 ]; then
          log_debug "Skipping $(basename "$FILE"): NotShowIn=$not_show (current: $current_de)"
          skipped=$((skipped+1))
          continue
        fi
      fi

      # Exec
      EXEC_LINE="$(get_field "$FILE" "Exec")"
      [ -z "$EXEC_LINE" ] && continue

      # Skip fragile Exec lines: shell -c or quoted args
      if echo "$EXEC_LINE" | grep -qE '^(sh|bash|/bin/sh|/bin/bash)[[:space:]]+-c' || echo "$EXEC_LINE" | grep -q '"'; then
        log_warn "Skipping fragile Exec ($(basename "$FILE")) — contains shell -c or quoted args"
        skipped=$((skipped+1))
        continue
      fi

      # Already contains GPU env markers?
      if echo "$EXEC_LINE" | grep -qE 'DRI_PRIME|VK_ICD_FILENAMES|__GLX_VENDOR_LIBRARY_NAME|__NV_PRIME_RENDER_OFFLOAD'; then
        continue
      fi

      NAME="$(get_field "$FILE" "Name")"
      ICON="$(get_field "$FILE" "Icon")"
      CATEGORIES="$(get_field "$FILE" "Categories")"
      COMMENT="$(get_field "$FILE" "Comment")"
      TERMINAL="$(get_field "$FILE" "Terminal")"

      NAME="${NAME:-$APP_NAME}"
      ICON="${ICON:-$APP_NAME}"
      TERMINAL="${TERMINAL:-false}"

      # Deduplicate by target binary
      local target_bin
      target_bin="$(extract_target_bin "$tryexec" "$EXEC_LINE")"
      if [ -n "$target_bin" ]; then
        if [ -n "${seen_bins[$target_bin]:-}" ]; then
          log_debug "Skipping duplicate wrapper for same target: $target_bin"
          skipped=$((skipped+1))
          continue
        fi
        seen_bins[$target_bin]=1
      fi

      local WRAPPED_EXEC
      if [ "$USE_WRAPPER" -eq 1 ]; then
        WRAPPED_EXEC="${WRAPPER_SCRIPT} ${EXEC_LINE}"
      else
        local driver
        driver="$(detect_driver)"
        if [ "$driver" = "nvidia" ]; then
          WRAPPED_EXEC="env DRI_PRIME=1 __GLX_VENDOR_LIBRARY_NAME=nvidia __NV_PRIME_RENDER_OFFLOAD=1 ${EXEC_LINE}"
        else
          WRAPPED_EXEC="env DRI_PRIME=1 ${EXEC_LINE}"
        fi
      fi

      # Deterministic filename
      local sha
      sha="$(sha1sum "$FILE" | cut -d' ' -f1)"
      WRAPPED_FILE="$DEST_DIR/${APP_NAME}-nvidia-${sha:0:8}.desktop"

      if [ "$DRY_RUN" -eq 1 ]; then
        log_info "[dry-run] Would create: $(basename "$WRAPPED_FILE")"
        log_debug "  Original: $NAME"
        log_debug "  Exec: $WRAPPED_EXEC"
        count=$((count+1))
        continue
      fi

      # Atomic write + metadata (include backup/version markers)
      tmpf="$(mktemp "${DEST_DIR}/.tmp.XXXXXX")"
      cat > "$tmpf" <<EOF
[Desktop Entry]
Version=1.0
Type=Application
Name=${NAME} (NVIDIA)
Exec=${WRAPPED_EXEC}
Icon=${ICON}
Terminal=${TERMINAL}
Categories=${CATEGORIES}
Comment=${COMMENT:+$COMMENT - }Runs on NVIDIA GPU
PrefersNonDefaultGPU=true
X-NVIDIA-Wrapped=true
X-NVIDIA-Wrapper-Version=1.0
X-NVIDIA-Original-Desktop=${FILE}
X-NVIDIA-Reason=User requested GPU offload
X-NVIDIA-Wrapped-Date=$(date -Iseconds)
EOF

      mv -f "$tmpf" "$WRAPPED_FILE"
      chmod 0644 "$WRAPPED_FILE" || true
      tmpf=""

      if command -v desktop-file-validate &>/dev/null; then
        if ! desktop-file-validate "$WRAPPED_FILE" 2> /tmp/dfv.err; then
          log_warn "Validation failed for $(basename "$WRAPPED_FILE"); output follows:"
          sed -n '1,200p' /tmp/dfv.err || true
          rm -f /tmp/dfv.err
        fi
      fi

      count=$((count+1))
      log_info "Wrapped: $NAME"
    done < <(find "$SRC" -maxdepth 1 -type f -name '*.desktop' -print0)
  done

  # Update desktop database
  if [ "$DRY_RUN" -eq 0 ] && command -v update-desktop-database &>/dev/null; then
    log_info "Updating desktop database..."
    update-desktop-database "$DEST_DIR" 2>/dev/null || true
  fi

  echo
  log_info "Summary:"
  log_info "  Created: $count wrapped applications"
  log_info "  Skipped: $skipped apps"
  log_info "  Location: $DEST_DIR"

  if [ "$DRY_RUN" -eq 1 ]; then
    log_info "[dry-run] No files were written"
  else
    log_info ""
    log_info "Usage:"
    log_info "  • Search for '(NVIDIA)' in your app launcher"
    log_info "  • Restart launcher if apps don't appear immediately"
    log_info "  • List: $(basename "$0") --list"
    log_info "  • Explain: $(basename "$0") --explain <file>.desktop"
    log_info "  • Opt-out: Add app names to $USER_SKIP_CONF"
    log_info "  • Uninstall: $(basename "$0") --uninstall"
    log_info "  • Restore backups: $(basename "$0") --restore"
    log_info "  • Monitor power: cat /sys/class/drm/card*/device/power_state"
    if [ "$USE_WRAPPER" -eq 1 ]; then
      log_info "  • Wrapper script: $WRAPPER_SCRIPT"
      [ "$WRAPPER_LOGGING" -eq 1 ] && log_info "  • Logs: \$XDG_RUNTIME_DIR/nvidia-offload-*.log"
    fi
    [ -d "$BACKUP_DIR" ] && log_info "  • Backup: $BACKUP_DIR"
    echo
    log_info "Steam/Proton users:"
    log_info "  Add to game launch options: DRI_PRIME=1 PROTON_ENABLE_NVAPI=1 %command%"
  fi
}
# ------------------------------------------------------------------------------

# -------------------- verification helper --------------------------------------
create_verification_script() {
  [ "$DRY_RUN" -eq 1 ] || [ "$VERIFY_MODE" -eq 0 ] && return
  local verify_script="$HOME/.local/bin/nvidia-offload-verify"
  mkdir -p "$(dirname "$verify_script")"
  cat > "$verify_script" <<'VERIFY_EOF'
#!/usr/bin/env bash
echo "=== NVIDIA Offload Verification ==="
echo
if ! command -v glxinfo &>/dev/null; then
  echo "ERROR: glxinfo not found. Install mesa-utils."
  exit 1
fi
echo "1. OpenGL Renderer Test (DRI_PRIME=1)"
DRI_PRIME=1 glxinfo 2>/dev/null | grep "OpenGL renderer" || true
if command -v vulkaninfo &>/dev/null; then
  echo "2. Vulkan Device Test (DRI_PRIME=1)"
  DRI_PRIME=1 vulkaninfo --summary 2>/dev/null | grep "deviceName" || true
fi
VERIFY_EOF
  chmod +x "$verify_script"
  log_info "Created verification script: $verify_script"
  "$verify_script"
}
# ------------------------------------------------------------------------------

# -------------------- finish / run --------------------------------------------
validate_wrapper_path
check_nvidia
create_wrapper_script
backup_existing
wrap_applications
create_verification_script

# release lock by exiting (fd 9 closed automatically)
exit 0
